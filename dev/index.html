<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · ModalDecisionTrees.jl</title><meta name="title" content="Home · ModalDecisionTrees.jl"/><meta property="og:title" content="Home · ModalDecisionTrees.jl"/><meta property="twitter:title" content="Home · ModalDecisionTrees.jl"/><meta name="description" content="Documentation for ModalDecisionTrees.jl."/><meta property="og:description" content="Documentation for ModalDecisionTrees.jl."/><meta property="twitter:description" content="Documentation for ModalDecisionTrees.jl."/><meta property="og:url" content="https://aclai-lab.github.io/ModalDecisionTrees.jl/"/><meta property="twitter:url" content="https://aclai-lab.github.io/ModalDecisionTrees.jl/"/><link rel="canonical" href="https://aclai-lab.github.io/ModalDecisionTrees.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>ModalDecisionTrees.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/aclai-lab/ModalDecisionTrees.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/aclai-lab/ModalDecisionTrees.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="ModalDecisionTrees"><a class="docs-heading-anchor" href="#ModalDecisionTrees">ModalDecisionTrees</a><a id="ModalDecisionTrees-1"></a><a class="docs-heading-anchor-permalink" href="#ModalDecisionTrees" title="Permalink"></a></h1><p>Welcome to the documentation for <a href="https://github.com/aclai-lab/ModalDecisionTrees.jl">ModalDecisionTrees</a>.</p><ul><li><a href="#ModalDecisionTrees.AbstractDecision"><code>ModalDecisionTrees.AbstractDecision</code></a></li><li><a href="#ModalDecisionTrees.AbstractDecisionInternal"><code>ModalDecisionTrees.AbstractDecisionInternal</code></a></li><li><a href="#ModalDecisionTrees.AbstractDecisionLeaf"><code>ModalDecisionTrees.AbstractDecisionLeaf</code></a></li><li><a href="#ModalDecisionTrees.AbstractNode"><code>ModalDecisionTrees.AbstractNode</code></a></li><li><a href="#ModalDecisionTrees.AbstractScalarLogiset"><code>ModalDecisionTrees.AbstractScalarLogiset</code></a></li><li><a href="#ModalDecisionTrees.DTNode"><code>ModalDecisionTrees.DTNode</code></a></li><li><a href="#ModalDecisionTrees.InfoNode"><code>ModalDecisionTrees.InfoNode</code></a></li><li><a href="#ModalDecisionTrees.MCARTState"><code>ModalDecisionTrees.MCARTState</code></a></li><li><a href="#ModalDecisionTrees.MLJInterface.ModalDecisionTree"><code>ModalDecisionTrees.MLJInterface.ModalDecisionTree</code></a></li><li><a href="#ModalDecisionTrees.MLJInterface.ModalRandomForest"><code>ModalDecisionTrees.MLJInterface.ModalRandomForest</code></a></li><li><a href="#ModalDecisionTrees.RestrictedMCARTState"><code>ModalDecisionTrees.RestrictedMCARTState</code></a></li><li><a href="#AbstractTrees.children-Tuple{DTree}"><code>AbstractTrees.children</code></a></li><li><a href="#AbstractTrees.printnode-Tuple{IO, ModalDecisionTrees.DTInternal}"><code>AbstractTrees.printnode</code></a></li><li><a href="#ModalDecisionTrees.build_forest-Union{Tuple{U}, Tuple{L}, Tuple{SoleData.MultiLogiset, AbstractVector{L}}, Tuple{SoleData.MultiLogiset, AbstractVector{L}, Union{Nothing, AbstractVector{U}, Symbol}}} where {L&lt;:Union{AbstractFloat, Integer, String, CategoricalArrays.CategoricalValue}, U}"><code>ModalDecisionTrees.build_forest</code></a></li><li><a href="#ModalDecisionTrees.build_stump-Union{Tuple{U}, Tuple{L}, Tuple{SoleData.MultiLogiset, AbstractVector{L}}, Tuple{SoleData.MultiLogiset, AbstractVector{L}, Union{Nothing, AbstractVector{U}, Symbol}}} where {L&lt;:Union{AbstractFloat, Integer, String, CategoricalArrays.CategoricalValue}, U}"><code>ModalDecisionTrees.build_stump</code></a></li><li><a href="#ModalDecisionTrees.build_tree-Union{Tuple{U}, Tuple{L}, Tuple{SoleData.MultiLogiset, AbstractVector{L}}, Tuple{SoleData.MultiLogiset, AbstractVector{L}, Union{Nothing, AbstractVector{U}, Symbol}}} where {L&lt;:Union{AbstractFloat, Integer, String, CategoricalArrays.CategoricalValue}, U}"><code>ModalDecisionTrees.build_tree</code></a></li><li><a href="#ModalDecisionTrees.limit_threshold_domain-Union{Tuple{U}, Tuple{L}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{L}, AbstractVector{U}, ModalDecisionTrees.Loss, Function, Integer, Bool}} where {T, L&lt;:Union{AbstractFloat, Integer}, U}"><code>ModalDecisionTrees.limit_threshold_domain</code></a></li><li><a href="#ModalDecisionTrees.modalstep-Union{Tuple{W}, Tuple{Any, Integer, AbstractVector{W}, RestrictedDecision}, Tuple{Any, Integer, AbstractVector{W}, RestrictedDecision, Union{Val{true}, Val{false}}}} where W&lt;:SoleLogics.AbstractWorld"><code>ModalDecisionTrees.modalstep</code></a></li><li><a href="#ModalDecisionTrees.squashtoleaf-Tuple{AbstractVector{&lt;:Union{var&quot;#s16&quot;, var&quot;#s10&quot;} where {L&lt;:Union{AbstractFloat, Integer, String, CategoricalArrays.CategoricalValue}, D&lt;:ModalDecisionTrees.AbstractDecision, var&quot;#s16&quot;&lt;:(ModalDecisionTrees.AbstractDecisionLeaf{&lt;:L}), var&quot;#s10&quot;&lt;:ModalDecisionTrees.AbstractDecisionInternal{L, D}}}}"><code>ModalDecisionTrees.squashtoleaf</code></a></li><li><a href="#ModalDecisionTrees.wrap"><code>ModalDecisionTrees.wrap</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModalDecisionTrees.DTNode" href="#ModalDecisionTrees.DTNode"><code>ModalDecisionTrees.DTNode</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Union type for internal and decision nodes of a decision tree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/ModalDecisionTrees.jl/blob/7c4a43dfedf572b2718a7a0fa77aee7dbdfd0036/src/base.jl#L83-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModalDecisionTrees.AbstractDecision" href="#ModalDecisionTrees.AbstractDecision"><code>ModalDecisionTrees.AbstractDecision</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A decision is an object that is placed at an internal decision node, and influences on how the instances are routed to its left or right child.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/ModalDecisionTrees.jl/blob/7c4a43dfedf572b2718a7a0fa77aee7dbdfd0036/src/base.jl#L60-L63">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModalDecisionTrees.AbstractDecisionInternal" href="#ModalDecisionTrees.AbstractDecisionInternal"><code>ModalDecisionTrees.AbstractDecisionInternal</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for internal decision nodes of a decision tree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/ModalDecisionTrees.jl/blob/7c4a43dfedf572b2718a7a0fa77aee7dbdfd0036/src/base.jl#L78-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModalDecisionTrees.AbstractDecisionLeaf" href="#ModalDecisionTrees.AbstractDecisionLeaf"><code>ModalDecisionTrees.AbstractDecisionLeaf</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for leaves in a decision tree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/ModalDecisionTrees.jl/blob/7c4a43dfedf572b2718a7a0fa77aee7dbdfd0036/src/base.jl#L73-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModalDecisionTrees.AbstractNode" href="#ModalDecisionTrees.AbstractNode"><code>ModalDecisionTrees.AbstractNode</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for nodes in a decision tree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/ModalDecisionTrees.jl/blob/7c4a43dfedf572b2718a7a0fa77aee7dbdfd0036/src/base.jl#L66-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModalDecisionTrees.AbstractScalarLogiset" href="#ModalDecisionTrees.AbstractScalarLogiset"><code>ModalDecisionTrees.AbstractScalarLogiset</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Logical datasets with scalar features.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/ModalDecisionTrees.jl/blob/7c4a43dfedf572b2718a7a0fa77aee7dbdfd0036/src/interpret-onestep-decisions.jl#L25-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModalDecisionTrees.InfoNode" href="#ModalDecisionTrees.InfoNode"><code>ModalDecisionTrees.InfoNode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">InfoNode{T,S}
InfoLeaf{T}</code></pre><p>These types are introduced so that additional information currently not present in a <code>ModalDecisionTree</code>-structure – for example, the names of the variables – can be used for visualization. This additional information is stored in the variable <code>info</code> of these types. It is a <code>NamedTuple</code>. So it can be used to store arbitraty information, apart from the two points mentioned. In analogy to the type definitions of <code>ModalDecisionTree</code>, the generic type <code>S</code> is the type of the variable values used within a node as a threshold for the splits between its children and <code>T</code> is the type of the output given (basically, a Number or a String).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/ModalDecisionTrees.jl/blob/7c4a43dfedf572b2718a7a0fa77aee7dbdfd0036/src/interfaces/AbstractTrees.jl#L24-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModalDecisionTrees.MCARTState" href="#ModalDecisionTrees.MCARTState"><code>ModalDecisionTrees.MCARTState</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Recursion state for ModalCART (see paper On The Foundations of Modal Decision Trees)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/ModalDecisionTrees.jl/blob/7c4a43dfedf572b2718a7a0fa77aee7dbdfd0036/src/ModalCART-states.jl#L4-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModalDecisionTrees.RestrictedMCARTState" href="#ModalDecisionTrees.RestrictedMCARTState"><code>ModalDecisionTrees.RestrictedMCARTState</code></a> — <span class="docstring-category">Type</span></header><section><div><p>TODO document vector of current worlds for each instance and modality</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/ModalDecisionTrees.jl/blob/7c4a43dfedf572b2718a7a0fa77aee7dbdfd0036/src/ModalCART-states.jl#L9-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractTrees.children-Tuple{DTree}" href="#AbstractTrees.children-Tuple{DTree}"><code>AbstractTrees.children</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">children(node::InfoNode)</code></pre><p>Return for each <code>node</code> given, its children.</p><p>In case of a <code>ModalDecisionTree</code> there are always exactly two children, because the model produces binary trees where all nodes have exactly one left and one right child. <code>children</code> is used for tree traversal. The additional information <code>info</code> is carried over from <code>node</code> to its children.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/ModalDecisionTrees.jl/blob/7c4a43dfedf572b2718a7a0fa77aee7dbdfd0036/src/interfaces/AbstractTrees.jl#L68-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractTrees.printnode-Tuple{IO, ModalDecisionTrees.DTInternal}" href="#AbstractTrees.printnode-Tuple{IO, ModalDecisionTrees.DTInternal}"><code>AbstractTrees.printnode</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">printnode(io::IO, node::InfoNode)
printnode(io::IO, leaf::InfoLeaf)</code></pre><p>Write a printable representation of <code>node</code> or <code>leaf</code> to output-stream <code>io</code>. If <code>node.info</code>/<code>leaf.info</code> have a field called</p><ul><li><code>modality_variable_names</code> it is expected to be an array of arrays of variable names corresponding to the variable names used in the tree nodes; note that there are two layers of reference because variables are grouped into <code>modalities</code> (see MLJ&#39;s docs for ModalDecisionTree: @doc ModalDecisionTree) They will be used for printing instead of the ids.</li></ul><p>Note that the left subtree of any split node represents the &#39;yes-branch&#39;, while the right subtree  the &#39;no-branch&#39;, respectively. <code>print_tree</code> outputs the left subtree first and then below the right subtree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/ModalDecisionTrees.jl/blob/7c4a43dfedf572b2718a7a0fa77aee7dbdfd0036/src/interfaces/AbstractTrees.jl#L100-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModalDecisionTrees.build_forest-Union{Tuple{U}, Tuple{L}, Tuple{SoleData.MultiLogiset, AbstractVector{L}}, Tuple{SoleData.MultiLogiset, AbstractVector{L}, Union{Nothing, AbstractVector{U}, Symbol}}} where {L&lt;:Union{AbstractFloat, Integer, String, CategoricalArrays.CategoricalValue}, U}" href="#ModalDecisionTrees.build_forest-Union{Tuple{U}, Tuple{L}, Tuple{SoleData.MultiLogiset, AbstractVector{L}}, Tuple{SoleData.MultiLogiset, AbstractVector{L}, Union{Nothing, AbstractVector{U}, Symbol}}} where {L&lt;:Union{AbstractFloat, Integer, String, CategoricalArrays.CategoricalValue}, U}"><code>ModalDecisionTrees.build_forest</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">build_stump(X, Y, W = nothing; kwargs...)
build_tree(X, Y, W = nothing; kwargs...)
build_forest(X, Y, W = nothing; kwargs...)</code></pre><p>Train a decision stump (i.e., decision tree with depth 1), a decision tree, or a random forest model on logiset <code>X</code> with labels <code>Y</code> and weights <code>W</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/ModalDecisionTrees.jl/blob/7c4a43dfedf572b2718a7a0fa77aee7dbdfd0036/src/build.jl#L133-L141">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModalDecisionTrees.build_stump-Union{Tuple{U}, Tuple{L}, Tuple{SoleData.MultiLogiset, AbstractVector{L}}, Tuple{SoleData.MultiLogiset, AbstractVector{L}, Union{Nothing, AbstractVector{U}, Symbol}}} where {L&lt;:Union{AbstractFloat, Integer, String, CategoricalArrays.CategoricalValue}, U}" href="#ModalDecisionTrees.build_stump-Union{Tuple{U}, Tuple{L}, Tuple{SoleData.MultiLogiset, AbstractVector{L}}, Tuple{SoleData.MultiLogiset, AbstractVector{L}, Union{Nothing, AbstractVector{U}, Symbol}}} where {L&lt;:Union{AbstractFloat, Integer, String, CategoricalArrays.CategoricalValue}, U}"><code>ModalDecisionTrees.build_stump</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">build_stump(X, Y, W = nothing; kwargs...)
build_tree(X, Y, W = nothing; kwargs...)
build_forest(X, Y, W = nothing; kwargs...)</code></pre><p>Train a decision stump (i.e., decision tree with depth 1), a decision tree, or a random forest model on logiset <code>X</code> with labels <code>Y</code> and weights <code>W</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/ModalDecisionTrees.jl/blob/7c4a43dfedf572b2718a7a0fa77aee7dbdfd0036/src/build.jl#L34-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModalDecisionTrees.build_tree-Union{Tuple{U}, Tuple{L}, Tuple{SoleData.MultiLogiset, AbstractVector{L}}, Tuple{SoleData.MultiLogiset, AbstractVector{L}, Union{Nothing, AbstractVector{U}, Symbol}}} where {L&lt;:Union{AbstractFloat, Integer, String, CategoricalArrays.CategoricalValue}, U}" href="#ModalDecisionTrees.build_tree-Union{Tuple{U}, Tuple{L}, Tuple{SoleData.MultiLogiset, AbstractVector{L}}, Tuple{SoleData.MultiLogiset, AbstractVector{L}, Union{Nothing, AbstractVector{U}, Symbol}}} where {L&lt;:Union{AbstractFloat, Integer, String, CategoricalArrays.CategoricalValue}, U}"><code>ModalDecisionTrees.build_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">build_stump(X, Y, W = nothing; kwargs...)
build_tree(X, Y, W = nothing; kwargs...)
build_forest(X, Y, W = nothing; kwargs...)</code></pre><p>Train a decision stump (i.e., decision tree with depth 1), a decision tree, or a random forest model on logiset <code>X</code> with labels <code>Y</code> and weights <code>W</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/ModalDecisionTrees.jl/blob/7c4a43dfedf572b2718a7a0fa77aee7dbdfd0036/src/build.jl#L47-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModalDecisionTrees.limit_threshold_domain-Union{Tuple{U}, Tuple{L}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{L}, AbstractVector{U}, ModalDecisionTrees.Loss, Function, Integer, Bool}} where {T, L&lt;:Union{AbstractFloat, Integer}, U}" href="#ModalDecisionTrees.limit_threshold_domain-Union{Tuple{U}, Tuple{L}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{L}, AbstractVector{U}, ModalDecisionTrees.Loss, Function, Integer, Bool}} where {T, L&lt;:Union{AbstractFloat, Integer}, U}"><code>ModalDecisionTrees.limit_threshold_domain</code></a> — <span class="docstring-category">Method</span></header><section><div><p>References:</p><ul><li>&quot;Generalizing Boundary Points&quot;</li><li>&quot;Multi-Interval Discretization of Continuous-Valued Attributes for Classification Learning&quot;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/ModalDecisionTrees.jl/blob/7c4a43dfedf572b2718a7a0fa77aee7dbdfd0036/src/interpret-onestep-decisions.jl#L170-L174">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModalDecisionTrees.modalstep-Union{Tuple{W}, Tuple{Any, Integer, AbstractVector{W}, RestrictedDecision}, Tuple{Any, Integer, AbstractVector{W}, RestrictedDecision, Union{Val{true}, Val{false}}}} where W&lt;:SoleLogics.AbstractWorld" href="#ModalDecisionTrees.modalstep-Union{Tuple{W}, Tuple{Any, Integer, AbstractVector{W}, RestrictedDecision}, Tuple{Any, Integer, AbstractVector{W}, RestrictedDecision, Union{Val{true}, Val{false}}}} where W&lt;:SoleLogics.AbstractWorld"><code>ModalDecisionTrees.modalstep</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Perform the modal step, that is, evaluate an existential formula  on a set of worlds, eventually computing the new world set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/ModalDecisionTrees.jl/blob/7c4a43dfedf572b2718a7a0fa77aee7dbdfd0036/src/interpret-onestep-decisions.jl#L44-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModalDecisionTrees.squashtoleaf-Tuple{AbstractVector{&lt;:Union{var&quot;#s16&quot;, var&quot;#s10&quot;} where {L&lt;:Union{AbstractFloat, Integer, String, CategoricalArrays.CategoricalValue}, D&lt;:ModalDecisionTrees.AbstractDecision, var&quot;#s16&quot;&lt;:(ModalDecisionTrees.AbstractDecisionLeaf{&lt;:L}), var&quot;#s10&quot;&lt;:ModalDecisionTrees.AbstractDecisionInternal{L, D}}}}" href="#ModalDecisionTrees.squashtoleaf-Tuple{AbstractVector{&lt;:Union{var&quot;#s16&quot;, var&quot;#s10&quot;} where {L&lt;:Union{AbstractFloat, Integer, String, CategoricalArrays.CategoricalValue}, D&lt;:ModalDecisionTrees.AbstractDecision, var&quot;#s16&quot;&lt;:(ModalDecisionTrees.AbstractDecisionLeaf{&lt;:L}), var&quot;#s10&quot;&lt;:ModalDecisionTrees.AbstractDecisionInternal{L, D}}}}"><code>ModalDecisionTrees.squashtoleaf</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Squashes a vector of <code>DTNode</code>s into a single leaf using <code>bestguess</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/ModalDecisionTrees.jl/blob/7c4a43dfedf572b2718a7a0fa77aee7dbdfd0036/src/posthoc.jl#L418-L420">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModalDecisionTrees.wrap" href="#ModalDecisionTrees.wrap"><code>ModalDecisionTrees.wrap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">wrap(node::MDT.DTInternal, info = NamedTuple())
wrap(leaf::MDT.AbstractDecisionLeaf, info = NamedTuple())</code></pre><p>Add to each <code>node</code> (or <code>leaf</code>) the additional information <code>info</code> and wrap both in an <code>InfoNode</code>/<code>InfoLeaf</code>. Typically a <code>node</code> or a <code>leaf</code> is obtained by creating a decision tree using either the native interface of <code>ModalDecisionTrees.jl</code> or via other interfaces which are available for this package (e.g., <code>MLJ</code>, see their docs for further details). Using the function <code>build_tree</code> of the native interface returns such an object. To use a ModalDecisionTree <code>mdt</code> (obtained this way) with the abstraction layer provided by the <code>AbstractTrees</code>-interface implemented here and optionally add variable names (<code>modality_variable_names</code>, an arrays of arrays of strings)  use the following syntax:</p><ol><li><code>wdc = wrap(mdt)</code></li><li><code>wdc = wrap(mdt, (modality_variable_names = modality_variable_names, ))</code></li></ol><p>In the first case <code>mdt</code> gets just wrapped, no information is added. No. 2 adds variable names. Note that the trailing comma is needed, in order to create a NamedTuple.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/ModalDecisionTrees.jl/blob/7c4a43dfedf572b2718a7a0fa77aee7dbdfd0036/src/interfaces/AbstractTrees.jl#L46-L63">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModalDecisionTrees.MLJInterface.ModalDecisionTree" href="#ModalDecisionTrees.MLJInterface.ModalDecisionTree"><code>ModalDecisionTrees.MLJInterface.ModalDecisionTree</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ModalDecisionTree</code></pre><p>A model type for constructing a modal decision tree, based on <a href="unknown">unknown.jl</a>, and implementing the MLJ model interface.</p><p>From MLJ, the type can be imported using</p><pre><code class="nohighlight hljs">ModalDecisionTree = @load ModalDecisionTree pkg=unknown</code></pre><p>Do <code>model = ModalDecisionTree()</code> to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in <code>ModalDecisionTree(max_depth=...)</code>.</p><p><code>ModalDecisionTree</code> implements Modal C4.5. This classification and regression algorithm, originally presented in Manzella et al. (2021). &quot;Interval Temporal Random Forests with an Application to COVID-19 Diagnosis&quot;. 10.4230/LIPIcs.TIME.2021.7, is an extension of the CART and C4.5 <a href="https://en.wikipedia.org/wiki/Decision_tree_learning">decision tree learning algorithms</a> that leverages the expressive power of modal logics of time and space to perform temporal/spatial reasoning on non-scalar data, such as time-series and images.</p><p>The symbolic, probabilistic model is able to extract logical descriptions of the data in terms of logical formulas (see <a href="https://github.com/aclai-lab/SoleLogics.jl">SoleLogics.jl</a>) on atoms that are scalar conditions on the variables (or features); for example, min[V2] ≥ 10, that is, &quot;the minimum of variable 2 is not less than 10&quot;. As such, the model is suitable for tasks that involve non-scalar data, but require some level of interpretable and transparent modeling. At the moment, the only loss functions available are Shannon&#39;s entropy (classification) and variance (regression).</p><p><strong>Training data</strong></p><p>In MLJ or MLJBase, bind an instance <code>model</code> to data with     mach = machine(model, X, y) where</p><ul><li><code>X</code>: any table of input features (e.g., a <code>DataFrame</code>) whose columns each have one of the following element scitypes: <code>Continuous</code>, <code>Count</code>, <code>OrderedFactor</code>, or any 0-, 1-, 2-dimensional array with elements of these scitypes; check column scitypes with <code>schema(X)</code></li><li><code>y</code>: is the target, which can be any <code>AbstractVector</code> whose element scitype is <code>Multiclass</code>, <code>Continuous</code>, <code>Finite</code>, or <code>Textual</code>; check the scitype with <code>scitype(y)</code></li></ul><p>Train the machine with <code>fit!(mach)</code>.</p><p><strong>Hyper-parameters</strong></p><ul><li><p><code>max_depth=-1</code>:          Maximum depth of the decision tree (-1=any)</p></li><li><p><code>min_samples_leaf=4</code>:    Minimum number of samples required at each leaf</p></li><li><p><code>min_purity_increase=0.002</code>: Minimum value for the loss function needed for a split</p></li><li><p><code>max_purity_at_leaf=Inf</code>: Minimum value for the loss function needed for a split</p></li><li><p><code>max_modal_depth=-1</code>:          Maximum modal depth of the decision tree (-1=any). When this depth is reached, only propositional decisions are taken.</p></li><li><p><code>n_subfeatures=0</code>: Number of features to select at random at each node (0 for all),</p></li></ul><p>or a Function that outputs this number, given a number of available features.</p><ul><li><p><code>feature=[minimum, maximum]</code>  Feature functions to be used by the tree to mine scalar conditions (e.g., <code>minimum[V2] ≥ 10</code>)</p></li><li><p><code>featvaltype=Float64</code>     Output type for feature functions, when it cannot be inferred (e.g., with custom feature functions provided).</p></li><li><p><code>relations=nothing</code>       Relations that the model uses to look for patterns; it can be a symbol in [:IA, :IA3, :IA7, :RCC5, :RCC8],                           where :IA stands for <a href="https://en.wikipedia.org/wiki/Allen%27s_interval_algebra">Allen&#39;s Interval Algebra</a> (13 relations in 1D, 169 relations in 2D),                           :IA3 and :IA7 are <a href="https://www.sciencedirect.com/science/article/pii/S0004370218305964">coarser fragments with 3 and 7 relations, respectively</a>,                           :RCC5 and :RCC8 are <a href="https://en.wikipedia.org/wiki/Region_connection_calculus">Region Connection Calculus algebras</a> with 5 and 8 topological operators, respectively.                           Relations from :IA, :IA3, :IA7, capture directional aspects of the relative arrangement of two intervals in time (or rectangles in a 2D space),                            while relations from :RCC5 and :RCC8 only capture topological aspects and are therefore rotation and flip-invariant.                           This hyper-parameter defaults to either no relation (adimensional data), IA7 interval relations (1- and 2-dimensional data)..</p></li><li><p><code>initconditions=nothing</code> initial conditions for evaluating modal decisions at the root; it can be a symbol in [:start<em>with</em>global, :start<em>at</em>center].                           :start<em>with</em>global forces the first decision to be a <em>global</em> decision (e.g., <code>⟨G⟩ (minimum[V2] ≥ 10)</code>, which translates to &quot;there exists a region where the minimum of variable 2 is higher than 10&quot;).                           :start<em>at</em>center forces the first decision to be evaluated on the smallest central world, that is, the central value of a time-series, or the central pixel of an image.                           This hyper-parameter defaults to :start<em>with</em>global.</p></li><li><p><code>downsize=true</code> Whether to perform automatic downsizing, by means of moving average. In fact, this algorithm has high complexity   (both time and space), and can only handle small time-series (&lt; 100 points) &amp; small images (&lt; 10 x 10 pixels).   When set to <code>true</code>, automatic downsizing is performed; when it is an <code>NTuple</code> of <code>Integer</code>s, a downsizing of dimensional data   to match that size is performed.</p></li><li><p><code>print_progress=false</code>:  set to <code>true</code> for a progress bar</p></li><li><p><code>post_prune=false</code>:      set to <code>true</code> for post-fit pruning</p></li><li><p><code>merge_purity_threshold=1.0</code>: (post-pruning) merge leaves having                          combined purity <code>&gt;= merge_purity_threshold</code></p></li><li><p><code>display_depth=5</code>:       max depth to show when displaying the tree(s)</p></li><li><p><code>rng=Random.GLOBAL_RNG</code>: random number generator or seed</p></li></ul><ul><li><code>display_depth=5</code>:       max depth to show when displaying the tree</li></ul><p><strong>Operations</strong></p><ul><li><code>predict(mach, Xnew)</code>: return predictions of the target given features <code>Xnew</code> having the same scitype as <code>X</code> above.</li></ul><p><strong>Fitted parameters</strong></p><p>The fields of <code>fitted_params(mach)</code> are:</p><ul><li><code>model</code>: the tree object, as returned by the core algorithm</li><li><code>var_grouping</code>: the adopted grouping of the features encountered in training, in an order consistent with the output of <code>printmodel</code>.   The MLJ interface can currently deal with scalar, temporal and spatial features, but   has one limitation, and one tricky procedure for handling them at the same time.   The limitation is for temporal and spatial features to be uniform in size across the instances (the algorithm will automatically throw away features that do not satisfy this constraint).   As for the tricky procedure: before the learning phase, features are divided into groups (referred to as <code>modalities</code>) according to each variable&#39;s <code>channel size</code>, that is, the size of the vector or matrix.   For example, if X is multimodal, and has three temporal features :x, :y, :z with 10, 10 and 20 points, respectively,    plus three spatial features :R, :G, :B, with the same size 5 × 5 pixels, the algorithm assumes that :x and :y share a temporal axis,    :R, :G, :B share two spatial axis, while :z does not share any axis with any other variable. As a result,    the model will group features into three modalities:       - {1} [:x, :y]       - {2} [:z]       - {3} [:R, :G, :B]   and <code>var_grouping</code> will be [[&quot;x&quot;, &quot;y&quot;], [&quot;z&quot;], [&quot;R&quot;, &quot;G&quot;, &quot;B&quot;]].</li></ul><p>&quot;R&quot;, &quot;G&quot;, &quot;B&quot;]</p><p><strong>Report</strong></p><p>The fields of <code>report(mach)</code> are:</p><ul><li><code>printmodel</code>: method to print a pretty representation of the fitted model, with single argument the tree depth. The interpretation of the tree requires you to understand how the current MLJ interface of ModalDecisionTrees.jl handles features of different modals. See <code>var_grouping</code> above. Note that the split conditions (or decisions) in the tree are relativized to a specific modality, of which the number is shown.</li><li><code>var_grouping</code>: the adopted grouping of the features encountered in training, in an order consistent with the output of <code>printmodel</code>.   See <code>var_grouping</code> above.</li><li><code>feature_importance_by_count</code>: a simple count of each of the occurrences of the features across the model, in an order consistent with <code>var_grouping</code>.</li><li><code>classes_seen</code>: list of target classes actually observed in training.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MLJ
using ModalDecisionTrees
using Random

tree = ModalDecisionTree(min_samples_leaf=4)

# Load an example dataset (a temporal one)
X, y = ModalDecisionTrees.load_japanesevowels()
N = length(y)

mach = machine(tree, X, y)

# Split dataset
p = randperm(N)
train_idxs, test_idxs = p[1:round(Int, N*.8)], p[round(Int, N*.8)+1:end]

# Fit
fit!(mach, rows=train_idxs)

# Perform predictions, compute accuracy
yhat = predict_mode(mach, X[test_idxs,:])
accuracy = MLJ.accuracy(yhat, y[test_idxs])

# Access raw model
fitted_params(mach).model
report(mach).printmodel(3)

&quot;{1} ⟨G⟩ (max[coefficient1] &lt;= 0.883491)                 3 : 91/512 (conf = 0.1777)
✔ {1} ⟨G⟩ (max[coefficient9] &lt;= -0.157292)                      3 : 89/287 (conf = 0.3101)
│✔ {1} ⟨L̅⟩ (max[coefficient6] &lt;= -0.504503)                     3 : 89/209 (conf = 0.4258)
││✔ {1} ⟨A⟩ (max[coefficient3] &lt;= 0.220312)                     3 : 81/93 (conf = 0.8710)
 [...]
││✘ {1} ⟨L̅⟩ (max[coefficient1] &lt;= 0.493004)                     8 : 47/116 (conf = 0.4052)
 [...]
│✘ {1} ⟨A⟩ (max[coefficient2] &lt;= -0.285645)                     7 : 41/78 (conf = 0.5256)
│ ✔ {1} min[coefficient3] &gt;= 0.002931                   4 : 34/36 (conf = 0.9444)
 [...]
│ ✘ {1} ⟨G⟩ (min[coefficient5] &gt;= 0.18312)                      7 : 39/42 (conf = 0.9286)
 [...]
✘ {1} ⟨G⟩ (max[coefficient3] &lt;= 0.006087)                       5 : 51/225 (conf = 0.2267)
 ✔ {1} ⟨D⟩ (max[coefficient2] &lt;= -0.301233)                     5 : 51/102 (conf = 0.5000)
 │✔ {1} ⟨D̅⟩ (max[coefficient3] &lt;= -0.123654)                    5 : 51/65 (conf = 0.7846)
 [...]
 │✘ {1} ⟨G⟩ (max[coefficient9] &lt;= -0.146962)                    7 : 16/37 (conf = 0.4324)
 [...]
 ✘ {1} ⟨G⟩ (max[coefficient9] &lt;= -0.424346)                     1 : 47/123 (conf = 0.3821)
  ✔ {1} min[coefficient1] &gt;= 1.181048                   6 : 39/40 (conf = 0.9750)
 [...]
  ✘ {1} ⟨G⟩ (min[coefficient4] &gt;= -0.472485)                    1 : 47/83 (conf = 0.5663)
 [...]&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/ModalDecisionTrees.jl/blob/7c4a43dfedf572b2718a7a0fa77aee7dbdfd0036/src/interfaces/MLJ/docstrings.jl#L136-L232">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModalDecisionTrees.MLJInterface.ModalRandomForest" href="#ModalDecisionTrees.MLJInterface.ModalRandomForest"><code>ModalDecisionTrees.MLJInterface.ModalRandomForest</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ModalRandomForest</code></pre><p>A model type for constructing a modal random forest, based on <a href="unknown">unknown.jl</a>, and implementing the MLJ model interface.</p><p>From MLJ, the type can be imported using</p><pre><code class="nohighlight hljs">ModalRandomForest = @load ModalRandomForest pkg=unknown</code></pre><p>Do <code>model = ModalRandomForest()</code> to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in <code>ModalRandomForest(sampling_fraction=...)</code>. <code>ModalRandomForest</code> implements the standard <a href="https://en.wikipedia.org/wiki/Random_forest">Random Forest algorithm</a>, originally published in Breiman, L. (2001): &quot;Random Forests.&quot;, <em>Machine Learning</em>, vol. 45, pp. 5–32, based on Modal C4.5. This classification and regression algorithm, originally presented in Manzella et al. (2021). &quot;Interval Temporal Random Forests with an Application to COVID-19 Diagnosis&quot;. 10.4230/LIPIcs.TIME.2021.7, is an extension of the CART and C4.5 <a href="https://en.wikipedia.org/wiki/Decision_tree_learning">decision tree learning algorithms</a> that leverages the expressive power of modal logics of time and space to perform temporal/spatial reasoning on non-scalar data, such as time-series and images.</p><p>The symbolic, probabilistic model is able to extract logical descriptions of the data in terms of logical formulas (see <a href="https://github.com/aclai-lab/SoleLogics.jl">SoleLogics.jl</a>) on atoms that are scalar conditions on the variables (or features); for example, min[V2] ≥ 10, that is, &quot;the minimum of variable 2 is not less than 10&quot;. As such, the model is suitable for tasks that involve non-scalar data, but require some level of interpretable and transparent modeling. At the moment, the only loss functions available are Shannon&#39;s entropy (classification) and variance (regression).</p><p><strong>Training data</strong></p><p>In MLJ or MLJBase, bind an instance <code>model</code> to data with     mach = machine(model, X, y) where</p><ul><li><code>X</code>: any table of input features (e.g., a <code>DataFrame</code>) whose columns each have one of the following element scitypes: <code>Continuous</code>, <code>Count</code>, <code>OrderedFactor</code>, or any 0-, 1-, 2-dimensional array with elements of these scitypes; check column scitypes with <code>schema(X)</code></li><li><code>y</code>: is the target, which can be any <code>AbstractVector</code> whose element scitype is <code>Multiclass</code>, <code>Continuous</code>, <code>Finite</code>, or <code>Textual</code>; check the scitype with <code>scitype(y)</code></li></ul><p>Train the machine with <code>fit!(mach)</code>.</p><p><strong>Hyper-parameters</strong></p><ul><li><p><code>n_trees=10</code>:            number of trees to train</p></li><li><p><code>sampling_fraction=0.7</code>  fraction of samples to train each tree on</p></li></ul><ul><li><p><code>max_depth=-1</code>:          Maximum depth of the decision tree (-1=any)</p></li><li><p><code>min_samples_leaf=1</code>:    Minimum number of samples required at each leaf</p></li><li><p><code>min_purity_increase=-Inf</code>: Minimum value for the loss function needed for a split</p></li><li><p><code>max_purity_at_leaf=Inf</code>: Minimum value for the loss function needed for a split</p></li><li><p><code>max_modal_depth=-1</code>:          Maximum modal depth of the decision tree (-1=any). When this depth is reached, only propositional decisions are taken.</p></li><li><p><code>n_subfeatures</code>: Number of features to select at random at each node (0 for all),</p></li></ul><p>or a Function that outputs this number, given a number of available features. Defaulted to <code>ceil(Int, sqrt(x))</code>.</p><ul><li><p><code>feature=[minimum, maximum]</code>  Feature functions to be used by the tree to mine scalar conditions (e.g., <code>minimum[V2] ≥ 10</code>)</p></li><li><p><code>featvaltype=Float64</code>     Output type for feature functions, when it cannot be inferred (e.g., with custom feature functions provided).</p></li><li><p><code>relations=nothing</code>       Relations that the model uses to look for patterns; it can be a symbol in [:IA, :IA3, :IA7, :RCC5, :RCC8],                           where :IA stands for <a href="https://en.wikipedia.org/wiki/Allen%27s_interval_algebra">Allen&#39;s Interval Algebra</a> (13 relations in 1D, 169 relations in 2D),                           :IA3 and :IA7 are <a href="https://www.sciencedirect.com/science/article/pii/S0004370218305964">coarser fragments with 3 and 7 relations, respectively</a>,                           :RCC5 and :RCC8 are <a href="https://en.wikipedia.org/wiki/Region_connection_calculus">Region Connection Calculus algebras</a> with 5 and 8 topological operators, respectively.                           Relations from :IA, :IA3, :IA7, capture directional aspects of the relative arrangement of two intervals in time (or rectangles in a 2D space),                            while relations from :RCC5 and :RCC8 only capture topological aspects and are therefore rotation and flip-invariant.                           This hyper-parameter defaults to either no relation (adimensional data), IA7 interval relations (1- and 2-dimensional data)..</p></li><li><p><code>initconditions=nothing</code> initial conditions for evaluating modal decisions at the root; it can be a symbol in [:start<em>with</em>global, :start<em>at</em>center].                           :start<em>with</em>global forces the first decision to be a <em>global</em> decision (e.g., <code>⟨G⟩ (minimum[V2] ≥ 10)</code>, which translates to &quot;there exists a region where the minimum of variable 2 is higher than 10&quot;).                           :start<em>at</em>center forces the first decision to be evaluated on the smallest central world, that is, the central value of a time-series, or the central pixel of an image.                           This hyper-parameter defaults to :start<em>with</em>global.</p></li><li><p><code>downsize=true</code> Whether to perform automatic downsizing, by means of moving average. In fact, this algorithm has high complexity   (both time and space), and can only handle small time-series (&lt; 100 points) &amp; small images (&lt; 10 x 10 pixels).   When set to <code>true</code>, automatic downsizing is performed; when it is an <code>NTuple</code> of <code>Integer</code>s, a downsizing of dimensional data   to match that size is performed.</p></li><li><p><code>print_progress=false</code>:  set to <code>true</code> for a progress bar</p></li><li><p><code>post_prune=false</code>:      set to <code>true</code> for post-fit pruning</p></li><li><p><code>merge_purity_threshold=1.0</code>: (post-pruning) merge leaves having                          combined purity <code>&gt;= merge_purity_threshold</code></p></li><li><p><code>display_depth=5</code>:       max depth to show when displaying the tree(s)</p></li><li><p><code>rng=Random.GLOBAL_RNG</code>: random number generator or seed</p></li></ul><ul><li><code>n_subrelations=identity</code>            Number of relations to randomly select at any point of the tree. Must be a function of the number of the available relations. It defaults to <code>identity</code>, that is, consider all available relations.</li><li><code>n_subfeatures=x -&gt; ceil(Int64, sqrt(x))</code>             Number of functions to randomly select at any point of the tree. Must be a function of the number of the available functions. It defaults to <code>x -&gt; ceil(Int64, sqrt(x))</code>, that is, consider only about square root of the available functions.</li><li><code>ntrees=50</code>                   Number of trees in the forest.</li><li><code>sampling_fraction=0.7</code>          Fraction of samples to train each tree on.</li><li><code>rng=Random.GLOBAL_RNG</code>          Random number generator or seed.</li></ul><p><strong>Operations</strong></p><ul><li><code>predict(mach, Xnew)</code>: return predictions of the target given features <code>Xnew</code> having the same scitype as <code>X</code> above. Predictions are probabilistic, but uncalibrated.</li><li><code>predict_mode(mach, Xnew)</code>: instead return the mode of each prediction above.</li></ul><p><strong>Fitted parameters</strong></p><p>The fields of <code>fitted_params(mach)</code> are:</p><ul><li><code>model</code>: the forest object, as returned by the core algorithm</li><li><code>var_grouping</code>: the adopted grouping of the features encountered in training, in an order consistent with the output of <code>printmodel</code>.   The MLJ interface can currently deal with scalar, temporal and spatial features, but   has one limitation, and one tricky procedure for handling them at the same time.   The limitation is for temporal and spatial features to be uniform in size across the instances (the algorithm will automatically throw away features that do not satisfy this constraint).   As for the tricky procedure: before the learning phase, features are divided into groups (referred to as <code>modalities</code>) according to each variable&#39;s <code>channel size</code>, that is, the size of the vector or matrix.   For example, if X is multimodal, and has three temporal features :x, :y, :z with 10, 10 and 20 points, respectively,    plus three spatial features :R, :G, :B, with the same size 5 × 5 pixels, the algorithm assumes that :x and :y share a temporal axis,    :R, :G, :B share two spatial axis, while :z does not share any axis with any other variable. As a result,    the model will group features into three modalities:       - {1} [:x, :y]       - {2} [:z]       - {3} [:R, :G, :B]   and <code>var_grouping</code> will be [[&quot;x&quot;, &quot;y&quot;], [&quot;z&quot;], [&quot;R&quot;, &quot;G&quot;, &quot;B&quot;]].</li></ul><p><strong>Report</strong></p><p>The fields of <code>report(mach)</code> are:</p><ul><li><code>printmodel</code>: method to print a pretty representation of the fitted model, with single argument the depth of the trees. The interpretation of the tree requires you to understand how the current MLJ interface of ModalDecisionTrees.jl handles features of different modals. See <code>var_grouping</code> above. Note that the split conditions (or decisions) in the tree are relativized to a specific frame, of which the number is shown.</li><li><code>var_grouping</code>: the adopted grouping of the features encountered in training, in an order consistent with the output of <code>printmodel</code>.   See <code>var_grouping</code> above.</li><li><code>feature_importance_by_count</code>: a simple count of each of the occurrences of the features across the model, in an order consistent with <code>var_grouping</code>.</li><li><code>classes_seen</code>: list of target classes actually observed in training.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MLJ
using ModalDecisionTrees
using Random

forest = ModalRandomForest(ntrees = 50)

# Load an example dataset (a temporal one)
X, y = ModalDecisionTrees.load_japanesevowels()
N = length(y)

mach = machine(forest, X, y)

# Split dataset
p = randperm(N)
train_idxs, test_idxs = p[1:round(Int, N*.8)], p[round(Int, N*.8)+1:end]

# Fit
fit!(mach, rows=train_idxs)

# Perform predictions, compute accuracy
Xnew = X[test_idxs,:]
ynew = predict_mode(mach, Xnew) # point predictions
accuracy = MLJ.accuracy(ynew, y[test_idxs])
yhat = predict_mode(mach, Xnew) # probabilistic predictions
pdf.(yhat, &quot;1&quot;)    # probabilities for one of the classes (&quot;1&quot;)

# Access raw model
fitted_params(mach).model
report(mach).printmodel(3) # Note that the output here can be quite large.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/ModalDecisionTrees.jl/blob/7c4a43dfedf572b2718a7a0fa77aee7dbdfd0036/src/interfaces/MLJ/docstrings.jl#L231-L331">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Monday 28 October 2024 15:01">Monday 28 October 2024</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
